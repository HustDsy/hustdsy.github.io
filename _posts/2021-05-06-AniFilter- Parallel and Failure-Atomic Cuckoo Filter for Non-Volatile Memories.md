---
layout:     post
title:      AniFilter: Parallel and Failure-Atomic Cuckoo Filter for Non-Volatile Memories
subtitle:   PM版本上的过滤器
date:       2021-05-06
author:     HustDsy
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - 过滤器
    - Hash索引

---

> 这篇论文实现了一个PM友好的过滤器，主要是基于布谷过滤器进行改进。这篇博客记录一下文章中作者提出的优化点，公式推导以及实验对比。

## 1.背景介绍

近似成员查询数据结构(Approximate Membership Query)表示了一组用于近似成员查询的结构。AMQ对于将数据存储在DRAM，SSDS，硬盘上的数据库，网络管理等领域有很大的应用。对于这些存储媒介上的AMQS有很多的优化。新型非易失性内存兼顾了SSDs的持久性以及DRAM的低延迟。现在对于PM上的哈希，树等索引结构有了很大的优化，但是对于AMQS类似的数据结构优化几乎没有。这篇问文章的对比实验有BF(布隆过滤器)，CF(布谷过滤器)，MF( Morton Filter,一个基于DRAM进行优化的过滤器)，RSQF(Rank-and-Select Quotient Filter ,一个基于SSD进行优化的过滤器）。

## 2.设计方案

作者首先介绍了布谷过滤器，这一点详情见[布谷过滤器](https://hustdsy.github.io/2020/09/29/%E5%B8%83%E8%B0%B7%E9%B8%9F%E8%BF%87%E6%BB%A4%E5%99%A8/)。作者描述的主要的问题是布谷哈希在高负载因子下布谷哈希的频繁剔除操作会导致性能的下降。

#### 2.1 Spillable bucket

这个方案类似于线性探测。布谷哈希的频繁剔除操作对于PM来说是不友好的。作者给出线性探测的策略提高哈希的负载因子，这里比较独特的是每个桶的第一个槽才会用来被当做用来存储其它桶用来存储的数据。具体的插入流程如图所示

<img src="https://gitee.com/hustdsy/blog-img/raw/master/image-20210506204547197.png" alt="image-20210506204547197" style="zoom:50%;" />

<img src="https://gitee.com/hustdsy/blog-img/raw/master/image-20210506204508873.png" alt="image-20210506204508873" style="zoom:50%;" />

对于插入，插入方式是从右边往左边插入，假设现在有四个槽，索引分别为0，1，2，3；那么插入数据的方式就是从3开始往2，1，0插入。当插入数据满的时候，如果b\[1][0]存储的是别的桶冲突的数据，那么b\[1][1]中存储的值要大于b\[1][2]，否则b\[1][1]存储的数据要小于b\[1][2]。这样组来看的话 一共有8个位置+探测的距离的桶存储相同的key。

#### 2.2Lookahead Eviction

//暂时有个疑问，作者自身的方法都避免了这个剔除操作，现在来优化？？？

之前的布谷过滤器的剔除是桶里的每个数据都去寻找路径。比如对于索引为0，1，2，3的一个桶。对于槽为0的数据，对应的桶数据满了，但是会遍历一遍它关联的桶的所有的数据，为了减少这个开销，作者将标记位保持在DRAM中，记录桶是否满了，从而减少遍历开销，判断需要剔除哪一个数据。

#### 2.3 Bucket Primacy

查询的时候需要对桶进行探测，比如桶b和b+1，每次查询需要遍历两个吗？假设b没有发生过替换，那么查询的次数就相当于多了一次，那可以避免吗，答案是可以的。还是按0，1，2，3来做说明，用2，3的数据的大小顺序来判断是否发生过替换。(这点我感觉不发生替换的次数应该很少吧。。。我猜的)

<img src="https://gitee.com/hustdsy/blog-img/raw/master/image-20210507162726807.png" alt="image-20210507162726807" style="zoom:50%;" />

这里总结一下过滤器的插入操作，主要包括两个·提高负载因子的方法，一个是类似于线性探测，但是它比较独特的是，只有每个桶的第0个索引才能进行这一项操作。第二个就是驱逐操作，驱逐操作其实很类似于布谷哈希。主要就是剔除操作只在第二个桶中的指纹进行驱逐，作者为了加快驱逐操作，为每个桶设置了一个标记为来判断其满还是不满。为了加快查询操作，作者使用位置2，3的槽的key大小来标志其是否发生过迁移操作，从而减少对第二个桶的查询。为了判别哪些数据是线性探测来的，作者使用位置1和位置2的大小排序的数据进行判断。个

一个桶没存储溢出来的数据，也没驱逐数据到h2的时候，那么这个桶存储的key的顺序是 slot0<=slot1<=slot2<=slot3;当slot1>slot2时，意味着b[0]存储的是溢出的数据。当 slot2>slot3时，说明发生过驱逐。但是这有个问题？？这样子有个问题 比如 0，1，2，3存储的数据为1，2，3，4假设1存储了一个溢出来的数据，那么现在变成了1 3 2 4 再发生 驱逐时，变成 1 3 4 2;4>3了 更改了之前的顺序关系！！！

//可能论文后面有所改善，但是这个优化插入方法感觉很勉强，因为线性探测满了之后，该剔除还是该剔除！！

